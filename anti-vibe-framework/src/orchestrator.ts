import Anthropic from "@anthropic-ai/sdk";
import * as fs from "fs/promises";
import * as path from "path";
import chalk from "chalk";

// ============================================================================
// TYPES
// ============================================================================

export interface ProjectConfig {
  name: string;
  description: string;
  techStack: {
    backend: string;
    database: string;
    testing?: string;
  };
  features: string[];
  outputPath?: string;
}

export interface Plan {
  architecture: string;
  fileStructure: string[];
  dependencies: string[];
  implementation: string;
  agentTasks: AgentTask[];
}

export interface AgentTask {
  agentType: string;
  instruction: string;
  dependencies: string[];
  parallel: boolean;
}

export interface AgentResult {
  agentType: string;
  files: GeneratedFile[];
  success: boolean;
  error?: string;
  output: string;
}

export interface GeneratedFile {
  path: string;
  content: string;
  description: string;
}

export interface OrchestratorConfig {
  apiKey: string;
  model?: string;
  maxTokens?: number;
  thinkingBudget?: number;
  verbose?: boolean;
}

// ============================================================================
// BASE AGENT CLASS
// ============================================================================

export abstract class BaseAgent {
  abstract name: string;
  abstract role: string;

  constructor(
    protected anthropic: Anthropic,
    protected config: OrchestratorConfig
  ) {}

  protected async callClaude(instruction: string): Promise<string> {
    if (this.config.verbose) {
      console.log(chalk.gray(`  [${this.name}] Calling Claude...`));
    }

    const message = await this.anthropic.messages.create({
      model: this.config.model || "claude-sonnet-4-5-20250929",
      max_tokens: this.config.maxTokens || 4096,
      messages: [
        {
          role: "user",
          content: `You are a ${this.role}.

${instruction}

IMPORTANT:
- Think through the problem step by step before providing code
- Be specific and provide complete, working code
- Include comments explaining key decisions
- Follow best practices and security guidelines
- Make code production-ready
`,
        },
      ],
    });

    let result = "";
    for (const block of message.content) {
      if (block.type === "text") {
        result += block.text;
      }
    }

    return result;
  }

  protected parseFiles(output: string): GeneratedFile[] {
    const files: GeneratedFile[] = [];

    // Parse code blocks with file paths
    // Format: ```language:path/to/file.ext
    const filePattern = /```(?:[\w]+):([^\n]+)\n([\s\S]*?)```/g;
    let match;

    while ((match = filePattern.exec(output)) !== null) {
      files.push({
        path: match[1].trim(),
        content: match[2].trim(),
        description: `Generated by ${this.name}`,
      });
    }

    // Fallback: Parse standard code blocks if no files found
    if (files.length === 0) {
      const codePattern = /```[\w]*\n([\s\S]*?)```/g;
      let index = 0;
      while ((match = codePattern.exec(output)) !== null) {
        files.push({
          path: `${this.name}-output-${index}.txt`,
          content: match[1].trim(),
          description: `Generated code block ${index}`,
        });
        index++;
      }
    }

    return files;
  }

  abstract execute(plan: any, context?: any): Promise<AgentResult>;
}

// ============================================================================
// SPECIALIZED AGENTS
// ============================================================================

export class PlanningAgent extends BaseAgent {
  name = "planning";
  role = "System Architect and Technical Planner";

  async execute(projectConfig: ProjectConfig): Promise<AgentResult> {
    const instruction = `Create a detailed implementation plan for this project:

PROJECT: ${projectConfig.name}
DESCRIPTION: ${projectConfig.description}

TECH STACK:
- Backend: ${projectConfig.techStack.backend}
- Database: ${projectConfig.techStack.database}
- Testing: ${projectConfig.techStack.testing || "Jest"}

REQUIRED FEATURES:
${projectConfig.features.map((f, i) => `${i + 1}. ${f}`).join("\n")}

Provide:
1. **Architecture Overview**: High-level design
2. **File Structure**: Complete directory tree
3. **Dependencies**: All npm packages needed
4. **Implementation Plan**: Step-by-step tasks for other agents
5. **Agent Coordination**: Which agents should work in parallel vs sequential

Format your response as:
# Architecture
[description]

# File Structure
\`\`\`
[tree structure]
\`\`\`

# Dependencies
\`\`\`json:package.json
[full package.json]
\`\`\`

# Implementation Tasks
[detailed tasks for each agent]
`;

    try {
      const output = await this.callClaude(instruction);
      const files = this.parseFiles(output);

      return {
        agentType: this.name,
        files,
        success: true,
        output,
      };
    } catch (error) {
      return {
        agentType: this.name,
        files: [],
        success: false,
        error: error instanceof Error ? error.message : String(error),
        output: "",
      };
    }
  }
}

export class DatabaseAgent extends BaseAgent {
  name = "database";
  role = "Database Architect and Schema Designer";

  async execute(plan: Plan): Promise<AgentResult> {
    const instruction = `Based on this plan:

${plan.implementation}

Create the database layer:

1. **Schema Design**: Complete database schema
2. **Models**: ORM models (if using ORM)
3. **Migrations**: Database migration files
4. **Queries**: Common query functions
5. **Seed Data**: Optional test data

Provide complete, working code with proper:
- Foreign keys and relations
- Indexes for performance
- Constraints and validation
- Transaction support

Format each file as:
\`\`\`sql:database/schema.sql
[content]
\`\`\`

\`\`\`typescript:src/models/User.ts
[content]
\`\`\`
`;

    try {
      const output = await this.callClaude(instruction);
      const files = this.parseFiles(output);

      return {
        agentType: this.name,
        files,
        success: true,
        output,
      };
    } catch (error) {
      return {
        agentType: this.name,
        files: [],
        success: false,
        error: error instanceof Error ? error.message : String(error),
        output: "",
      };
    }
  }
}

export class APIAgent extends BaseAgent {
  name = "api";
  role = "Backend API Developer";

  async execute(plan: Plan, dbResult?: AgentResult): Promise<AgentResult> {
    const dbContext = dbResult?.output || "No database context provided";

    const instruction = `Based on this plan:

${plan.implementation}

Database Schema:
${dbContext}

Create the API layer:

1. **Routes**: All HTTP endpoints
2. **Controllers**: Business logic handlers
3. **Middleware**: Auth, validation, error handling
4. **Services**: Reusable business logic
5. **Main Server**: Express/Fastify setup

Provide complete, working code with:
- RESTful design
- Error handling
- Input validation
- Authentication/Authorization
- Proper HTTP status codes

Format each file as:
\`\`\`typescript:src/routes/users.ts
[content]
\`\`\`
`;

    try {
      const output = await this.callClaude(instruction);
      const files = this.parseFiles(output);

      return {
        agentType: this.name,
        files,
        success: true,
        output,
      };
    } catch (error) {
      return {
        agentType: this.name,
        files: [],
        success: false,
        error: error instanceof Error ? error.message : String(error),
        output: "",
      };
    }
  }
}

export class TestAgent extends BaseAgent {
  name = "test";
  role = "QA Engineer and Test Specialist";

  async execute(plan: Plan, apiResult?: AgentResult): Promise<AgentResult> {
    const apiContext = apiResult?.output || "No API context provided";

    const instruction = `Based on this implementation:

${plan.implementation}

API Code:
${apiContext}

Create comprehensive tests:

1. **Unit Tests**: Test individual functions
2. **Integration Tests**: Test API endpoints
3. **E2E Tests**: Test full workflows
4. **Test Utilities**: Helpers and fixtures

Provide complete, working tests with:
- Good coverage
- Clear test names
- Proper setup/teardown
- Mock data
- Edge cases

Format each file as:
\`\`\`typescript:tests/unit/users.test.ts
[content]
\`\`\`
`;

    try {
      const output = await this.callClaude(instruction);
      const files = this.parseFiles(output);

      return {
        agentType: this.name,
        files,
        success: true,
        output,
      };
    } catch (error) {
      return {
        agentType: this.name,
        files: [],
        success: false,
        error: error instanceof Error ? error.message : String(error),
        output: "",
      };
    }
  }
}

export class DocsAgent extends BaseAgent {
  name = "docs";
  role = "Technical Writer and Documentation Specialist";

  async execute(plan: Plan, allResults?: AgentResult[]): Promise<AgentResult> {
    const context = allResults?.map(r => r.output).join("\n\n") || "";

    const instruction = `Based on this project:

${plan.implementation}

Implementation:
${context}

Create complete documentation:

1. **README.md**: Setup, usage, examples
2. **API.md**: API documentation
3. **ARCHITECTURE.md**: System design
4. **CONTRIBUTING.md**: How to contribute

Provide complete, well-formatted markdown with:
- Clear instructions
- Code examples
- Troubleshooting
- Best practices

Format each file as:
\`\`\`markdown:README.md
[content]
\`\`\`
`;

    try {
      const output = await this.callClaude(instruction);
      const files = this.parseFiles(output);

      return {
        agentType: this.name,
        files,
        success: true,
        output,
      };
    } catch (error) {
      return {
        agentType: this.name,
        files: [],
        success: false,
        error: error instanceof Error ? error.message : String(error),
        output: "",
      };
    }
  }
}

// ============================================================================
// MAIN ORCHESTRATOR
// ============================================================================

export class AntiVibeOrchestrator {
  private anthropic: Anthropic;
  private agents: Map<string, BaseAgent>;

  constructor(private config: OrchestratorConfig) {
    this.anthropic = new Anthropic({ apiKey: config.apiKey });

    // Initialize agents
    this.agents = new Map();
    this.agents.set("planning", new PlanningAgent(this.anthropic, config));
    this.agents.set("database", new DatabaseAgent(this.anthropic, config));
    this.agents.set("api", new APIAgent(this.anthropic, config));
    this.agents.set("test", new TestAgent(this.anthropic, config));
    this.agents.set("docs", new DocsAgent(this.anthropic, config));
  }

  async buildProject(projectConfig: ProjectConfig): Promise<void> {
    console.log(chalk.bold.cyan(`\nüéØ ANTI-VIBE FRAMEWORK: Building ${projectConfig.name}\n`));
    console.log(chalk.gray("=".repeat(70)));

    const startTime = Date.now();

    try {
      // PHASE 1: Planning
      console.log(chalk.bold.yellow("\nüìã PHASE 1: PLANNING (Thinking Mode)\n"));
      const planningAgent = this.agents.get("planning")!;
      const planResult = await planningAgent.execute(projectConfig);

      if (!planResult.success) {
        throw new Error(`Planning failed: ${planResult.error}`);
      }

      console.log(chalk.green("  ‚úì Architecture planned"));
      console.log(chalk.green("  ‚úì File structure defined"));
      console.log(chalk.green("  ‚úì Dependencies identified"));

      // Extract plan from output
      const plan: Plan = {
        architecture: planResult.output,
        fileStructure: [],
        dependencies: [],
        implementation: planResult.output,
        agentTasks: [],
      };

      // PHASE 2: Parallel Implementation
      console.log(chalk.bold.yellow("\n‚ö° PHASE 2: PARALLEL GENERATION\n"));

      const [dbResult, apiResult, testResult] = await Promise.all([
        this.executeAgent("database", plan),
        this.executeAgent("api", plan),
        this.executeAgent("test", plan),
      ]);

      console.log(chalk.green(`  ‚úì Database Agent: ${dbResult.files.length} files generated`));
      console.log(chalk.green(`  ‚úì API Agent: ${apiResult.files.length} files generated`));
      console.log(chalk.green(`  ‚úì Test Agent: ${testResult.files.length} files generated`));

      // PHASE 3: Documentation
      console.log(chalk.bold.yellow("\nüìö PHASE 3: DOCUMENTATION\n"));

      const docsResult = await this.executeAgent("docs", plan, [dbResult, apiResult, testResult]);
      console.log(chalk.green(`  ‚úì Docs Agent: ${docsResult.files.length} files generated`));

      // PHASE 4: Save Files
      console.log(chalk.bold.yellow("\nüíæ PHASE 4: SAVING FILES\n"));

      const outputPath = projectConfig.outputPath || `./output/${projectConfig.name}`;
      const allFiles = [
        ...planResult.files,
        ...dbResult.files,
        ...apiResult.files,
        ...testResult.files,
        ...docsResult.files,
      ];

      await this.saveFiles(allFiles, outputPath);

      console.log(chalk.green(`  ‚úì ${allFiles.length} files saved to ${outputPath}`));

      // Summary
      const duration = ((Date.now() - startTime) / 1000).toFixed(2);
      console.log(chalk.gray("\n" + "=".repeat(70)));
      console.log(chalk.bold.green(`\nüéâ SUCCESS!\n`));
      console.log(chalk.cyan(`üì¶ Output: ${outputPath}`));
      console.log(chalk.cyan(`üìÅ Files: ${allFiles.length}`));
      console.log(chalk.cyan(`‚è±Ô∏è  Time: ${duration} seconds`));
      console.log(chalk.cyan(`üòå Stress Level: Minimal\n`));

    } catch (error) {
      console.log(chalk.bold.red(`\n‚ùå BUILD FAILED\n`));
      console.log(chalk.red(error instanceof Error ? error.message : String(error)));
      throw error;
    }
  }

  private async executeAgent(
    agentType: string,
    plan: Plan,
    previousResults?: AgentResult[]
  ): Promise<AgentResult> {
    const agent = this.agents.get(agentType);
    if (!agent) {
      throw new Error(`Agent ${agentType} not found`);
    }

    if (this.config.verbose) {
      console.log(chalk.gray(`  [${agentType}] Starting...`));
    }

    return await agent.execute(plan, previousResults);
  }

  private async saveFiles(files: GeneratedFile[], basePath: string): Promise<void> {
    // Create base directory
    await fs.mkdir(basePath, { recursive: true });

    for (const file of files) {
      const fullPath = path.join(basePath, file.path);
      const dir = path.dirname(fullPath);

      // Create directory if needed
      await fs.mkdir(dir, { recursive: true });

      // Write file
      await fs.writeFile(fullPath, file.content, "utf-8");

      if (this.config.verbose) {
        console.log(chalk.gray(`    Saved: ${file.path}`));
      }
    }
  }
}
